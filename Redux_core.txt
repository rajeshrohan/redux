Redux 			: core redux 
Redux-thunk     : middleware for async task
redux-logger 	: logs every action 

React-Redux     : binds redux state into react state
Redux-toolkit   
RTK Query       : api fetching 
Redux Saga      

1. Redux concept terms, pattern 
2. Redux with React , problems, solution 
3. Redux toolkit (RTK) with react 
4. RTK query with React 
5. project with RTK Async Thunk 

-------------------------------------------------
Redux :
A library used for global state management.
provides a global store to access and change from anywhere.
solves problem of lifting state which leads to props drilling. 
used in : 
1. Big applications
2. High frequency of state changes.

Redux pattern : 
store 	 : global store 
state    : amount 
action   : increment, decrement
Reducer  : fn with algorithms and filter 
dispatch : sends action to reducer.
middleware : to pause, delay, modifiy in-btwn dispatch and reducer.

Three principles of Redux:
Single source of truth 		→ The whole app state is stored in one store.
State is read-only 			→ State can only be changed by dispatching actions.
Changes by pure fns only	→ Reducers calculate the next state.

-------------------------------------------------
npm install redux 
npm install redux-logger 

import {createStore, applyMiddleware} from 'redux';
import logger from 'redux-logger';

const store = createStore(reducer, applyMiddleware(logger.default));
const history = [ ];
const Increment = 'increment';
const Decrement = 'decrement';
const IncrementByAmount = 'incrementByAmount';

function reducer (state={amount : 1}, action){
if(action.type === Increment)
	return {amount : state.amount + 1};
else if(action.type == Decrement)
	return {amount : state.amount -1};
else if(action.type === IncrementByAmount)
	return {amount : state.amount + action.payload};
 return state;
}

store.subscribe(()=>{
history.push(store.getState());
console.log(history);
});

function increment(){
	return {type : Increment}
}
function decrement(){
	return {type : Decrement}
}
function incrementByAmount(value){
	return {type : IncrementByAmount, payload : value}
}

setInterval(()=>{
store.dispatch(incrementByAmount(5));
}, 2000);

---------------------------------------------------------------
createStore : 
a function that creates a Redux store.
configureStore (from Redux Toolkit) is the recommended standard.
configureStore replaces manual createStore + applyMiddleware setup.
syntax : createStore(reducer, [preloadedState], [enhancer]);

store provides : 
store.getState() 			-> Returns the current state tree of the application.
store.dispatch(action)		-> Sends an action to the reducer to update state.
store.subscribe(listener) 	-> Registers a callback that runs after every dispatch.

reducer : a pure fn that receives (state, action) and must return next state.
action  : a object must have a type property and additional fields (payload).

Redux follows unidirectional data flow, dispatch(action) sends action to the store.
dispatch sends action to the store, store calls the reducer with (currentState, action).
Reducers must return The new state object OR the existing state (if nothing changed)

applyMiddleware 	: used with createStore.
In modern Redux, middleware is added automatically via configureStore.
Middleware intercepts actions before they reach the reducer.

Redux Thunk  : 
It extends dispatch so it can accept Plain objects and Functions also.
aim : handle asynchronous side effects without breaking reducer purity.
built-in default in Redux Toolkit.
ex : 
dispatch(actionObject) or dispatch(function).

Action Creator : 
A function that returns an action object.
aim : Avoid duplication, maintainability, readability, Encapsulation
action names can mismatch, so use constans.

--------------------------------------------------------
Thunk Middleware :
npm install redux-thunk

problem : 
the core store only supports dispatching plain objects
It does not support dispatching functions or handling async logic.
we need middleware (Thunk or createAsyncThunk).
Redux toolkit has in-built Redux-Thunk middleware by default.
Note : 
dispatch should be sync, immediate, not async.

create 	: json file db.json 
install : npm install json-serever --save-dev 
run 	: npx json-server db.json
get req : axios.get('url');
create  : create using a fn, and call api inside 
Error.  : Actions must be plain objects. 
		Instead, the actual type was: 'Promise'

to make await : write a fn 

now inside dispatch, pass function reference. 
now action creator gets two params(dispatch, getState).
and it will itself stop. 
now you can directly dispatch in action creator. 
you will notice dispatch runs 2 times. 

when store dispatch, 
typeof action === "function"
it executes action(dispatch, getState);

flow : 
dispatch(getUser(1))
        ↓
getUser(1) returns function
        ↓
thunk middleware detects function
        ↓
thunk calls function(dispatch, getState)
        ↓
your async logic runs

------------------------
we need new Reducer for new data field logic,
else it will more complex the logic, and unreadable. 
1. make state more complex 
2. state update will be more complex
3. nested state will not work, objects are shallow copy. 

there should be only one root reducer. 
so use combineReduders provided by redux.
takes a object , with name of each. 

getState = global state, 
reducer state = each object in global state.

same action is received by all reducers,
each can satisfy condition on it,
but each reducer changes their own state only. 

flow : 
store - getState(), takes reducer fns, middlewares
dispatch -> action creator -> action -> middleware -> reducer case.

--------------------------------------------------------
Immmer library : 
write mutable-looking code but producing immutable state updates.
Immer provides a function:   produce() 
draft is a Proxy-wrapped copy of your state.

import { produce } from "immer";

const state = { count: 0 };
const newState = produce(state, draft => {
  draft.count = 5;
});



* pure fn : same i/p same o/p, no side effects.